from requests import *
from string import printable
import random
import hashlib
from Crypto.Util.number import getPrime
from json import loads
from Crypto.PublicKey import ECC
from Crypto.Signature import DSS
import re

URL = "http://176.118.164.39:31337" 
s = Session()
m = 64
q_secp_256 = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551


def gen(n):
    return "".join(random.choice(printable[:62]) for i in range(n))


def parametr_p(m):
    p = getPrime(int(m))
    return p

def parametr_a_b(p):#Любая функция генерации параметров a и b
    A = 0
    B = 0
    while (4 * pow(A,3,p) + 27 * pow(B,2,p) ) % p == 0:#Проверяем, что дискриминант не равен 0, это нужно для использования EllipticCurve и подсчета порядка 
        Seed = random.randint(1,p)
        H = hashlib.md5( str(Seed).encode() + b"Helllooo" )
        H = "0x" + H.hexdigest()
        prost = random.randint(2,10)
        H_1 = H[:int(len(H)//prost)]
        H_1 = int(H_1 , 0)
        A = pow(H_1 , 3 , p)
        prost = random.randint(2,10)
        H = H[:int(len(H)//prost)]
        H = int(H,0)
        B = pow(H,5,p)
    return A,B

def por_prover(E_por,p):
    
    h = 1

    if E_por == p:
        return -1
    if E_por % 2 == 0:
        k = E_por // 2
        h = 2
    elif E_por % 3 == 0:
        k =   E_por // 3 
        h = 3
    else:
        k = E_por
    if k%2 == 0:
        k =  k // 2
        h = 4
    if is_prime(k) == 0:
        return -1
    return h

def gen_parametrs(m):
    while True:#Генерируем параметры с порядком, удовлетворяющим заданным требованиям
        p = parametr_p(m)
        a,b = parametr_a_b(p)
        E = EllipticCurve(GF(p) , [a,b])
        q = E.order()
        if por_prover(q,p) != -1:
            return p,a,b,q

def check_q(f):
    for k in f:
        if len(str(k[0])) > 10:
            return False
    return True

def gen_G(E):
    i = 0
    while True:
        try:
            G = E.lift_x(i)
            return G
        except:
            i += 1

req = s.post(URL + "/sign",data = {"username" : gen(10),"password" : gen(10)}) #регаемся с рандомным именем и паролем

Mass_Mod = []
Mass_remainder = []

while len(Mass_Mod) != 7:# для восстановления 384 битного секрета необходимо такой модуль, чтобы он был больше 384 бит, семь 64-битных модулей будет достаточно
    p, a, b, q = gen_parametrs(m)
    i = 1
    while True:
        E1 = EllipticCurve(GF(p) , [a,i])
        #После чего приступаем непосредственно к атаке
        q1 = E1.order()
        f = factor(q1)
        G = gen_G(E1)
        new_q = G.order()
        if check_q(f) == True and new_q > q:   #для успешной атаки достаточно сгенерировать ЭК с таким порядком, у которого в разложении не будет больше 10-значных чисел
            (gx,gy,z) = G
            Mass_Mod.append(q)
            req = s.post(URL + "/create_certificate",data = {"curve_name":"custom", "p" : p, "a" : a , "b" : b , "q" : q , "gx" : gx , "gy" : gy})# Важно учесть, что Secret берется по mod q, который должен соотвестввать требованиям, поэтому до этого важно, чтобы new_q > q
            cert = loads(req.text)

            Public = re.findall(r"point_x = (\d+), point_y = (\d+)",cert["Info"]["Public key"])
            px = int(Public[0][0])
            py = int(Public[0][1])
            P = E1(px,py)
            d_p = discrete_log(P , G , operation = "+")
            Mass_remainder.append(int(d_p))
            break
            
        i += 1

secret = CRT(Mass_remainder , Mass_Mod)
print("Secret : ",secret)
d_256 = secret % q_secp_256
print("Secret mod Order secp256r : ",d_256) # на всякий случай можно проверить, что при умножении на базовую точку кривой Secp256r мы получим публичный ключ из сертификата с этой кривой

f = open("secret.txt","w")
f.write(str(secret))
f.close()
#Последнюю часть пришлось реализовать на Python3 из-за того, что в Sage 9.2 может не работать нормально библиотека Pycrypto
